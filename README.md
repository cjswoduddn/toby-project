# 토비의 스프링(2021-01-29~)

- AOP에서 막혀서 다시 시작

## 시작하기
- 학습하는 장에서 작업을 시작
- 한 장이 끝난 경우
마스터에서 끝난 장을 머지하고 새로운 장의 브렌치를 만든다

## 목차
[1장 초난감DAO](#1장-초난감DAO)
[2장 테스트](#2장-테스트)
[3장 템플릿](#3장-템플릿)

## 1장 초난감DAO
- 공부 기간(2021/1/29 ~ 2021/1/30)
- 3번째 읽는 중^^..

### 결합도가 강한 초난감DAO
- 기본적인 DB서비스 과정
1) DB연결 정보를 제공하여 DB연결
2) 쿼리 생성
3) 쿼리 수행 및 결과 반환
4) DB연결 반환

### 매번 달라지는 DB연결 정보

1. DB연결이 바뀔 때마다 모든 메서드를 수행해야할까?
-> DB연결 작업만 메서드로 분리하기

2. 결국 클래스의 변경이 일어나는 건 막지 못할까?
-> DB연결을 추상메서드로 만들고 상속받아 재구현하기

3. 상속이 강제되면 다른 유연함을 포기해야할텐데?
-> 다른 클래스에게 DB연결 책임을 위임
private final DataSource dataSource;
DataSource는 인터페이스이며
DataSource의 구현체를 통해 초기화해야함

### DataSource의 초기화는 누가? 언제?

1. DataSource의 초기화를 소유 클래스가 직접한다면?
결국 DataSource의 구현체가 바뀔 때마다 소유클래스 코드 변경

2. 생성자를 이용한 초기화
외부에서 구현체를 직접 정한다.
제어의 역전, 의존성 주입 사용

### 초기화 책임의 분리

많은 객체를 다루기 위해 아예 생성 전용 클래스를 만든다.
-> 스프링컨테이너의 등장배경

결국
1. 프로그래머가 스프링컨테이너 조립
2. 프로그램 실행
3. 스프링컨테이너가 생성할 모든 클래스에 적절한 의존성 주입

의존성이 변경될 때마다 스프링컨테이너만 조작하면 된다.
그 외 다른 코드는 건드릴 필요가 없다.


## 2장 테스트
### 자동화된 테스트를 작성하자
시나리오에 맞게 assertEqual assertThrow 와 같은 메서드 활용

### 설계한 서비스로직을 테스트로 먼저 작성하자
서비스 시나리오를 모두 테스트로 작성한 뒤 본 서비스를 작성하자

## 3장 템플릿

### DB와 관련된 공통 프로세스
자원을 얻어오는 프로세스는 적절하게 분리 완료한 상태
그렇다면 DB와 연결하는 공통된 프로세스를 다시 분리할 수 없을까?

1) DB연결 정보를 제공하여 DB연결
2) 쿼리 생성
3) 쿼리 수행 및 결과 반환
4) DB연결 반환

### context메서드 생성
공통된 작업을 수행하는 틀을 생성하고 원하는 PreparedStatement만 전달하는 구조
PreparedStatement를 직접 상속받아 클래스를 만들어 전달할 수도 있지만 그보다는 익명클래스를 사용해 전달하는 방식 채용

### 모든 DB작업은 위와 비슷할텐데?
context작업을 클래스의 메서드 수준이 아닌 클래스로 빼서 범용으로 만들어고, context를 사용하려는 클래스는 이 클래스를 주입받자

### context가 필요한 Statement
PreparedStatement는 클라이언트가 만들어서 context 클래스에 전달했다. 맞는건가?
그럼 모든 서비스 메서드는 PreparedStatement를 만드는 코드를 넣어야 한다. 더 나아가 모든 context사용 클래스도 마찬가지다.

결국 PreparedStatement를 만드는 과정도 중복으로 볼 수 있고 클라이언드가 전달해줄 값은 쿼리와 쿼리의 파라미터다.
context를 가진 메서드에서 PreparedStatement의 생산 책임도 갖자.
